// =========================================================
// Runes & Remnants — Harvest Menu
// =========================================================

//TODO the math is not correct but the placement looks correct. the system is trtying to assign the DC of creature CR, type, rarity but it should be a flat number

import {
  MODULE_ID,
  computeHarvestDC,
  grantMaterial,
  getHarvestOptions,
  rollAssessment,
  rollCarving,
  finalHarvestResult,
  getEssenceByCR,
  computeHelperBonus,
  HARVEST_SKILL_BY_TYPE
} from "./logic.js";

export class HarvestMenu extends Application {
  constructor(initialTokenDoc = null, options = {}) {
    super(options);
    this.targetToken = initialTokenDoc ?? null;
    this.targetActor = this.targetToken?.actor ?? null;

    this.loot = [];
    this._lootLoaded = false;
    this.selectedLoot = new Set();

    // Roles
    this.assessor = null;
    this.harvester = null;
    this.helpers = [];
  }

  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: "rnr-harvest-menu",
      title: "Harvest Materials",
      template: "modules/runes-and-remnants/templates/harvest-dialog.html",
      width: 700,
      height: "auto",
      classes: ["rnr-harvest", "grimdark"]
    });
  }

  // ---------------------- Data Loading ----------------------

  async _ensureLootIndex() {
    if (this._lootLoaded) return;

    const pack = game.packs.get("runes-and-remnants.harvest-items");
    if (!pack) return;
    const idx = await pack.getIndex();
    this.loot = idx.contents ?? idx;

    // Always append essence based on CR
    const cr = Number(this.targetActor?.system?.details?.cr ?? 0);
    const essence = getEssenceByCR(cr);
    this.loot.push({
      _id: `essence-${cr}`,
      name: essence.name,
      type: "loot",
      system: { rarity: essence.rarity },
      flags: { "runes-and-remnants": { autoGenerated: true, baseDC: essence.dc } }
    });

    this._lootLoaded = true;
  }

  _actorSummary(actor) {
    const type = actor?.system?.details?.type?.value ?? actor?.system?.details?.type ?? "Unknown";
    const cr = actor?.system?.details?.cr ?? actor?.system?.details?.challenge ?? "—";
    return { type, cr };
  }

  _getPortrait(actor) {
    if (!actor) return "icons/svg/mystery-man.svg";
    return actor.img || actor.prototypeToken?.texture?.src || "icons/svg/mystery-man.svg";
  }

  _skillKeyForType(type) {
    const nameToKey = { Arcana: "arc", Survival: "sur", Religion: "rel", Investigation: "inv", Medicine: "med", Nature: "nat" };
    const skillName = HARVEST_SKILL_BY_TYPE[String(type).toLowerCase()] ?? "Survival";
    return { skillName, skillKey: nameToKey[skillName] ?? "sur" };
  }

  _getAvailableActors() {
    const allActors = Array.from(game.actors.values());
    const activeUsers = game.users.filter(u => u.active);
    const activeUserIds = new Set(activeUsers.map(u => u.id));

    const sceneActorIds = new Set(
      (canvas?.tokens?.placeables ?? [])
        .map(t => t.actor?.id)
        .filter(Boolean)
    );

    const weighted = allActors.map(a => {
      const isPC = a.type === "character";
      const owners = game.users.filter(u => a.testUserPermission(u, "OWNER"));
      const activeOwners = owners.filter(u => activeUserIds.has(u.id));

      let priority = 3;
      if (isPC && activeOwners.length) priority = 1;
      else if (sceneActorIds.has(a.id)) priority = 2;

      return {
        id: a.id,
        name: a.name,
        img: this._getPortrait(a),
        priority
      };
    });

    weighted.sort((a, b) => a.priority - b.priority || a.name.localeCompare(b.name));
    return weighted;
  }

  // ---------------------- Data for Template ----------------------

  async getData() {
    await this._ensureLootIndex();

    const targetName = this.targetActor?.name ?? "Unknown Target";
    const targetImg = this._getPortrait(this.targetActor);
    const { type, cr } = this._actorSummary(this.targetActor);
    const sizeKey = this.targetActor?.system?.traits?.size ?? "med";

    const { skillName, skillKey } = this._skillKeyForType(type);
    const { total: helperBonus, cap: helperCap } = computeHelperBonus(this.helpers, skillKey, sizeKey);
    this._helperCap = helperCap;

    const helperBonusClass =
      helperBonus <= 0 ? "none" :
      helperBonus <= 3 ? "low" :
      helperBonus <= 6 ? "medium" : "high";

    const sameActor = !!(this.assessor?.actorId && this.harvester?.actorId &&
                         this.assessor.actorId === this.harvester.actorId);

    const availableActors = this._getAvailableActors();
    const takenHelperIds = new Set(this.helpers.map(h => h.actorId));
    const assessorId  = this.assessor?.actorId  ?? null;
    const harvesterId = this.harvester?.actorId ?? null;

    const availableForAssessor  = availableActors.filter(a => !takenHelperIds.has(a.id));
    const availableForHarvester = availableActors.filter(a => !takenHelperIds.has(a.id));
    const availableHelpers      = availableActors.filter(a => a.id !== assessorId && a.id !== harvesterId && !takenHelperIds.has(a.id));


    return {
      hasTarget: !!this.targetActor,
      targetName, targetImg, type, cr, sizeKey,
      loot: this.loot,
      selectedLoot: Array.from(this.selectedLoot),
      assessor: this.assessor,
      harvester: this.harvester,
      helpers: this.helpers,
      helperBonus, helperBonusClass, helperCap,
      availableForAssessor, availableForHarvester, availableHelpers,
      sameActor
    };
  }

  // ---------------------- UI Listeners ----------------------

  activateListeners(html) {
  super.activateListeners(html);

  // --- Assessor Selection ---
  html.on("click", "[data-action='set-assessor']", ev => {
    const el = ev.currentTarget;
    const actorId = el.dataset.actorId;

    // Allow same actor to be harvester (for disadvantage case)
    this.assessor = { actorId, name: el.dataset.actorName, img: el.dataset.actorImg };

    // Remove from helpers only
    this.helpers = this.helpers.filter(h => h.actorId !== actorId);
    this.render(true);
  });

  html.on("click", "[data-action='remove-assessor']", () => {
    this.assessor = null;
    this.render(true);
  });

  // --- Harvester Selection ---
  html.on("click", "[data-action='set-harvester']", ev => {
    const el = ev.currentTarget;
    const actorId = el.dataset.actorId;

    // Allow same actor to be assessor (for disadvantage case)
    this.harvester = { actorId, name: el.dataset.actorName, img: el.dataset.actorImg };

    // Remove from helpers only
    this.helpers = this.helpers.filter(h => h.actorId !== actorId);
    this.render(true);
  });

  html.on("click", "[data-action='remove-harvester']", () => {
    this.harvester = null;
    this.render(true);
  });

  // --- Helper Add/Remove ---
  html.on("click", "[data-action='add-helper']", ev => {
    const el = ev.currentTarget;
    const actorId = el.dataset.actorId;

    // Prevent using same actor if they’re already assessor or harvester
    if (this.assessor?.actorId === actorId || this.harvester?.actorId === actorId)
      return ui.notifications.warn("That actor already has a role.");
    if (this.helpers.some(h => h.actorId === actorId)) return;

    const { type } = this._actorSummary(this.targetActor);
    const sizeKey = this.targetActor?.system?.traits?.size ?? "med";
    const { skillKey } = this._skillKeyForType(type);
    const { cap } = computeHelperBonus([], skillKey, sizeKey);

    if (this.helpers.length >= cap)
      return ui.notifications.warn(`You cannot assign more than ${cap} helpers for a ${sizeKey} creature.`);

    this.helpers.push({ actorId, name: el.dataset.actorName, img: el.dataset.actorImg });
    this.render(true);
  });

  html.on("click", "[data-action='remove-helper']", ev => {
    const li = ev.currentTarget.closest("li[data-index]");
    const i = Number(li.dataset.index);
    if (Number.isInteger(i)) this.helpers.splice(i, 1);
    this.render(true);
  });

  // --- Loot Checkbox ---
  html.on("change", "input[name='lootChoice']", ev => {
    const id = ev.currentTarget.value;
    ev.currentTarget.checked ? this.selectedLoot.add(id) : this.selectedLoot.delete(id);
  });

  // --- Begin Harvest ---
  html.on("click", "[data-action='start-harvest']", async () => this._startHarvest());
}

  // ---------------------- Harvest Execution ----------------------
  async _startHarvest() {
    if (!this.targetActor)
      return ui.notifications.warn("No target creature selected.");

    if (!this.assessor || !this.harvester)
      return ui.notifications.warn("Assign both an Assessor and a Harvester first.");

    const helpers = this.helpers ?? [];
    const { type, cr } = this._actorSummary(this.targetActor);
    const sizeKey = this.targetActor?.system?.traits?.size ?? "med";

    const pack = game.packs.get("runes-and-remnants.harvest-items");
    if (!pack)
      return ui.notifications.error("Harvest Items compendium not found.");

    // Ensure data arrays exist for testing
    if (!game.rnrHarvestItems) {
      game.rnrHarvestItems = [{ _id: "mock-item", name: "Test Material" }];
    }
    if (!game.rnrHarvestTable) {
      game.rnrHarvestTable = [{ creatureType: "other", components: [{ dc: 10, items: ["Test Material"] }] }];
    }


    const assessorActor = game.actors.get(this.assessor.actorId);
    const harvesterActor = game.actors.get(this.harvester.actorId);
    if (!assessorActor || !harvesterActor)
      return ui.notifications.error("One or more assigned actors could not be found.");

    // --- Handle same-actor disadvantage ---
    const sameActor = assessorActor.id === harvesterActor.id;
    if (sameActor)
      ui.notifications.warn(`${assessorActor.name} is performing both roles — both rolls are made at disadvantage.`);

    // --- Perform Rolls ---
    const assess = await rollAssessment(assessorActor, type, { disadvantage: sameActor });
    const carve  = await rollCarving(harvesterActor, type, { disadvantage: sameActor });

    // --- Totals & DC ---
    const harvestTotal = assess.total + carve.total;
    const baseDC = computeHarvestDC({ cr, type, rarity: "common", baseDC: 10 });
    const skillName = HARVEST_SKILL_BY_TYPE[String(type).toLowerCase()] ?? "Survival";
    const skillKey = skillName.toLowerCase().slice(0, 3);

    // --- Helper Bonus ---
    const { total: helperBonus, breakdown: helperBreakdown, cap: helperCap } =
      computeHelperBonus(helpers, skillKey, sizeKey);

    const totalRoll = harvestTotal + helperBonus;
    const result = finalHarvestResult(baseDC, totalRoll);

    // --- Gather Materials (never early-return) ---
    const typeData = getHarvestOptions(type) ?? [];
    const materials = [];

    for (const tier of typeData)
      if (totalRoll >= tier.dc) materials.push(...tier.items);

    // Always add essence even if table empty
    const essence = getEssenceByCR(Number(cr) || 0);
    materials.push(essence.name);

    // --- Drop or Grant Materials ---
    const dropPoint = this.targetToken?.object?.center ?? null;
    for (const itemName of materials) {
      const itemEntry = game.rnrHarvestItems.find(i => i.name === itemName);
      if (!itemEntry) continue;
      try {
        const itemDoc = await pack.getDocument(itemEntry._id);
        await grantMaterial({ item: itemDoc, qty: 1, toActor: harvesterActor, dropAt: dropPoint });
      } catch (err) {
        console.warn(`[${MODULE_ID}] Failed to grant ${itemName}:`, err);
      }
    }

    // --- Build Helper Breakdown ---
    const helperList = helperBreakdown.length
      ? helperBreakdown.map(h =>
          `<li>${h.name}: +${h.contribution} (${h.proficient ? "proficient" : "half"})</li>`
        ).join("")
      : "<li>None</li>";

    // --- Build Chat Output ---
    const disadvantageNote = sameActor
      ? `<p class="warning">⚠️ ${this.assessor.name} performed both roles — both rolls at disadvantage.</p>`
      : "";

    const chatContent = `
    <div class="rnr-harvest-summary">
      <hr>
      <h3><b>Harvest Summary</b></h3>
      ${disadvantageNote}
      <p><b>Target:</b> ${this.targetActor.name} (CR ${cr}, ${type})</p>
      <ul>
        <li><b>Assessment:</b> ${this.assessor.name} — ${skillName} (rolled ${assess.total})</li>
        <li><b>Carving:</b> ${this.harvester.name} — ${skillName} (rolled ${carve.total})</li>
        <li><b>Helper Bonus:</b> +${helperBonus} (cap: ${helperCap})</li>
      </ul>
      <p><b>Roll Breakdown:</b> ${assess.total} + ${carve.total} + ${helperBonus} =
        <b style="color:#8ef;">${totalRoll}</b> vs DC <b>${baseDC}</b></p>
      <p><b>Outcome:</b> <span style="color:${result.includes('success') ? '#80ff80' : '#ff8080'};">${result}</span></p>
      <p><b>Recovered:</b> ${materials.join(', ') || 'Nothing recovered'}</p>
    </div>
    `;

    // --- Create Final Chat Message ---
    console.log(`[${MODULE_ID}] Harvest summary posted`, { totalRoll, baseDC, result });

    // Wait briefly so roll cards appear first
    await new Promise(r => setTimeout(r, 500));

    await ChatMessage.create({
      speaker: { alias: "Runes & Remnants" },
      content: chatContent
    });

    // Allow UI to update before token deletion
    await new Promise(r => setTimeout(r, 200));
    await this.targetToken.document.delete();
  } 
}